#! /usr/bin/env python
# -*- coding: utf-8 -*-
#    
#    Copyright (C) 2011  Larytet
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


#  This script reads file generated by ofd470 and creates list of global 
#  variables, their type, address
#  The input file is generated using 
#  ofd470 --dwarf_display=none,dinfo,types,nodaranges,nodabbrev --obj_display=none -g -o <file_name> image.out  
# Output file looks like this
# OBJECT FILE:  .\out\test.out
# 
#  DWARF Debugging Information Entries in Section ".debug_info"
# 
#     ----------------------------
#     DIE Table at Offset 00000000
#     ----------------------------
# 
#     Length:                   98472
#     Version:                      2
#     .debug_abbrev Offset:  00000000
#     Address Size:                 4
# 
# 
#     0000000b  12 DW_TAG_compile_unit
#     0000000c        DW_AT_name       .\f1\test.c
#     0000002a        DW_AT_stmt_list  .debug_line + 0x0
#     0000002e        DW_AT_language   DW_LANG_C
#     0000002f        DW_AT_producer   TI TMS470 Linker PC v4.4.2 Cop
#                                      yright (c) 1996-2007 Texas Ins
#                                      truments Incorporated
#     00000081        DW_AT_TI_version 1
#     00000082  64    DW_TAG_variable
#     00000083           DW_AT_location       DW_OP_addr 0x20006e74
#     ..............................................................
 
 
import sys, re, fileinput, os, tempfile;
from optparse import OptionParser;
from array import *

verboseOutput = False;
cmdOptions = False;
includeDictionary = False;
excludeDictionary = False;
COMMENT_CHAR = '#';

def strHex(value, width=8, prefix=''):
    if (value == None):
        value = 0xFFFFFFFF;
    valueStr = hex(value)
    valueStr = valueStr.lstrip("0x")
    valueStr = valueStr.rstrip("L")
    valueStr = valueStr.lower();
    if (width > 0):
        valueStr = valueStr.zfill(width)   # add zeros the left

    valueStr = prefix + valueStr

    return valueStr

    
# returns false if mandatory args are not there 
def checkArgs(args):
    rc = False;

    while (True): # I need only one iteration

        if (not args.debugInfoFile):
            break;
            
        # args are consistent
        rc = True;
        
        # break from the loop - one iteration loop
        break;
        
    return rc;

# Open a file for reading or writing
# Returns handle to the open file and result code False/True
def openFile(filename, flag):
   try:
      fileHandle = open(filename, flag) # read text file
   except Exception:
      print 'Failed to open file', filename
      print sys.exc_info()
      return (False, False)
   else:
      return (True, fileHandle)



def createOptionsParser():
    # create parser for the command line options
    parser = OptionParser();

    # command line options 
    parser.add_option("-t", "--types", dest="debugInfoFile", metavar="FILE", help="File containing types and variables. This is a result of ofd470. For example, \nofd470 --dwarf_display=none,dinfo,types,nodaranges,nodabbrev --obj_display=none -g --output types ROM.out", default=False);
    parser.add_option("-i", "--include", dest="includeFile", metavar="FILE", 
                      help="File contains list of variables. List contains regular expressions separated by a new line.\n"
                      " If list is empty or no list is specified all symbols will be processed\n" 
                                        "Examples:                                              " 
                      "'stat' Include global variable 'stat'                                    "
                      "'stat.+' RegEx:include all variables 'stat*'                              "
                      "'stat.aggSize.txAggVsRate cols=4' print 4 columns                         " 
                      "'stat.aggSize.txAggVsRate fmt=%08X' hexadecimal                           ", 
                      default=False);
    parser.add_option("--osh", dest="generateShell", metavar="FILE", help="Generate shell script", default=None);
    parser.add_option("--oraw", dest="generateRaw", metavar="FILE", help="Generate indented ASCII output", default=None);
    parser.add_option("-v", "--verbose", dest="verboseOutput", metavar="true/false", help="Print full debug info", default=False);
    return parser;


def updateDictionary(dict, symbolName, flag):
    tup = dict[symbolName];
    if (len(tup) == 2):
        (lineNum, b) = tup;
        del dict[symbolName];             
        dict[symbolName] = (lineNum, flag);
    elif (len(tup) == 4):
        (lineNum, symbolNameNew, destSection, b) = tup;
        del dict[symbolName];             
        dict[symbolName] = (lineNum, destSection, flag);
    else:
        printError("Internal", lineNum, True, "wrong size of tuple in the dictionary "+len(tup));
    

def checkRegex(line):
    res = True;
    try:
        re.compile(line);
    except Exception:
        res = False;
    
    return res;


def readIncludeList(fileName, fileList, dict):
    global COMMENT_CHAR;
    # There are two options - substring and regular expression
    pattern = '^([A-Za-z \\\/]+)$'; # Folder name or file path
    lineNum = 1;
    for line in fileList:
        line = (line.split(COMMENT_CHAR, 1))[0];
        line = line.strip()
        if (line == ""): continue;        
        match = re.match(pattern, line);
        if (match):
            incluePath = match.group(1);
            if (not incluePath in dict):
                dict[incluePath] = (lineNum, incluePath, False);
            else:
                (lineNumPrev, _, _) = dict[incluePath];
                printError(fileName, lineNum, True, "Path "+incluePath+" is redefined");
                printError(fileName, lineNumPrev, True, "Previous definition of "+incluePath);
        else: # Is it a regex?
            regEx = line;
            res = checkRegex(regEx);
            if (res):
                 if (not regEx in dict):
                     dict[regEx] = (lineNum, regEx, True);
                 else:
                     (lineNumPrev, _, _) = dict[regEx];
                     printError(fileName, lineNum, True, "Path "+regEx+" is redefined");
                     printError(fileName, lineNumPrev, True, "Previous definition of "+regEx);
            else:
                printError(fileName, lineNum, True, "Path "+regEx+" is not well formed regular expression");
            
        lineNum = lineNum + 1;

def printNotUsedSymbols(filename, dict):
    for symbolName in dict:
        tup = dict[symbolName];
        if (len(tup) == 2):
            (lineNum, hit) = dict[symbolName];
            if (not hit):
                printError(filename, lineNum, False, "not used "+symbolName);
        if (len(tup) == 4):
            (lineNum, nameNew, nameDest, hit) = dict[symbolName];
            if (not hit):
                printError(filename, lineNum, False, "not used "+symbolName);

def printError(fileName, lineNum, isError, message):
    if (isError):
        print '"{0}", line {1}: error: {2}'.format(fileName, lineNum, message);
    else:
        print '"{0}", line {1}: warning: {2}'.format(fileName, lineNum, message);


# Base call for all nodes - variables, types, base types 
class Node(object):
    
    def __init__(self, line, address):
        object.__init__(self)

        # line number in the input  file where the node definition starts 
        self.lineNum = line;
        # address as specified by the right most column
        self.address = address;
        # name of the variable, type
        self.name = None;
        
        
    def isVariable(self):
        return False;

    def isType(self):
        return False;

    def isTypeRef(self):
        return False;

    def isArray(self):
        return False;

    def isPointer(self):
        return False;

    def dbgPrint(self):
        if (self.isType()):
            print "Type: Name={0}, line={1}, address={2}".format(self.name, self.lineNum, strHex(self.address));
        elif (self.isVariable()):
            print "Variable: Name={0}, line={1}, address={2}, typeAddress={3}".format(
                self.name, self.lineNum, strHex(self.address), strHex(self.typeAddress));
        else:
            # print "??: Name={0}, line={1}, address={2}".format(self.name, self.lineNum, self.address);
            pass
    
class VariableNode(Node):

    def __init__(self, line, address):
        Node.__init__(self, line, address);
        # type reference address
        self.typeAddress = None;
        
        # type node
        self.type = None;
    
        # physical address 
        self.location = None;
        
    def isVariable(self):
        return True;
    
    def dbgPrint(self):
        print "Variable: Name={0}, line={1}, address={2}, typeAddress={3}".format(
            self.name, self.lineNum, strHex(self.location), strHex(self.typeAddress));


class TypeRefNode(Node):
    
    def __init__(self, line, address):
        Node.__init__(self, line, address);
        # type address
        self.typeAddress = None;
        # type 
        self.type = None;
    
    def isTypeRef(self):
        return True;

    def dbgPrint(self):
        print "TypeRef: Name={0}, line={1}, address={2}, typeAddress={3}".format(
            self.name, self.lineNum, strHex(self.address), strHex(self.typeAddress));

class TypeNode(Node):

    def __init__(self, line, address):
        Node.__init__(self, line, address);
        # size in bytes
        self.size = None;

    def isType(self):
        return True;

    def isPointer(self):
        return False;

    def isArray(self):
        return False;

    def isUnion(self):
        return False;
    
    def isVolatile(self):
        return False;

    def isStructure(self):
        return False;

    def isBaseType(self):
        return False;
    
class BaseTypeNode(TypeNode):
    
    def __init__(self, line, address):
        TypeNode.__init__(self, line, address);
        # boolean
        self.isSigned = None;

    def isBaseType(self):
        return True;

    def dbgPrint(self):
        print "BaseType: Name={0}, line={1}, address={2}, bytes={3}, signed={4}".format(
            self.name, self.lineNum, strHex(self.address), self.size, self.isSigned);

class EnumerationTypeNode(TypeNode):
    
    def __init__(self, line, address):
        TypeNode.__init__(self, line, address);
        # list of tuples (string, value)
        self.members = [];

    def isBaseType(self):
        return True;

    def dbgPrint(self):
        print "EnumerationType: Name={0}, line={1}, address={2}, bytes={3}".format(
            self.name, self.lineNum, strHex(self.address), len(self.members));

class StructureNode(TypeNode):
    def __init__(self, line, address):
        TypeNode.__init__(self, line, address);
        # list of tuples (name, typeRef/type)
        self.fields = []

    def isStructure(self):
        return True;

class StructureFieldNode(Node):
    
    def __init__(self, line, address):
        Node.__init__(self, line, address);
        # type reference address
        self.typeAddress = None;
        # type reference Node
        self.typeRef = None;
        # type node
        self.type = None;
        # offset of the field
        self.location = None;

    def dbgPrint(self):
        print "StructField: line={0}, address={1}, typeAddress={2}".format(
            self.lineNum, strHex(self.address), strHex(self.typeAddress));

class UnionNode(TypeNode):

    def __init__(self, line, address):
        TypeNode.__init__(self, line, address);
        # list of StructureFieldNode objects
        self.fields = []

    def isUnion(self):
        return True;

class ArrayNode(TypeNode):


    def __init__(self, line, address):
        TypeNode.__init__(self, line, address);
        # type reference address
        self.typeAddress = None;
        # type reference Node
        self.typeRef = None;
        # type node
        self.type = None;
        # list of dimensions 
        self.rangeBounds = [];
    
    def isArray(self):
        return True;

    def dbgPrint(self):
        print "Array: line={0}, address={1}, typeAddress={2}, size={3}, dimsCount={4}".format(
            self.lineNum, strHex(self.address), strHex(self.typeAddress), self.size, self.rangeBounds);

        
class PointerNode(TypeNode):
    
    def __init__(self, line, address):

        TypeNode.__init__(self, line, address);
        # type reference address
        self.typeAddress = None;
        # type reference Node
        self.typeRef = None;
        # type node
        self.type = None;
    
    def isPointer(self):
        return True;

class VolatileNode(TypeNode):

    def __init__(self, line, address):
        TypeNode.__init__(self, line, address);
        # type reference address
        self.typeAddress = None;
        # type reference Node
        self.typeRef = None;
        # type node
        self.type = None;

    def isVolatile(self):
        return True;

# Dictionary of nodes
class Nodes:
    
    def __init__(self):
        self.variables = []
        # Dictionary of types - key is an address
        self.types = {}
        # Dictionary of typeRefs - key is an address
        self.typeRefs = {}


LINE_DIETABLE = 0
LINE_NAME = 1
LINE_COMPILEUNIT = 2
LINE_VARIABLE = 3
LINE_LOCATION = 4
LINE_TYPE = 5
LINE_TYPEDEF = 6
LINE_POINTERTYPE = 7
LINE_STRUCTURE = 8               
LINE_BYTESIZE = 9           
LINE_MEMBER =  10            
LINE_MEMBERLOCATION = 11   
LINE_UNION = 12
LINE_SUBPROGRAM = 13       
LINE_ARRAYTYPE = 14          
LINE_UPPERBOUND = 15        
LINE_BASETYPE = 16 
LINE_ADDRESSCLASS = 17
LINE_SUBRANGETYPE = 18
LINE_CONSTTYPE = 19
LINE_SUBROUTINETYPE = 20
LINE_SYMBOLNAME = 21
LINE_ACCESSIBILITY = 22
LINE_ENUMERATIONTYPE = 23 
LINE_ENUMERATOR = 24
LINE_CONSTVALUE = 25
LINE_VOLATILETYPE = 26
LINE_ENCODING = 27
LINE_LINEWRAP = 28


LINE_TYPE_TO_STRING = (
"DIETABLE",
"NAME",
"COMPILEUNIT",
"VARIABLE",
"LOCATION",
"TYPE",
"TYPEDEF",
"POINTERTYPE",
"STRUCTURE",
"BYTESIZE",
"MEMBER",
"MEMBERLOCATION",
"UNION",
"SUBPROGRAM",
"ARRAYTYPE",
"UPPERBOUND",
"BASETYPE",
"ADDRESSCLASS",
"SUBRANGETYPE",
"CONSTTYPE",
"SUBROUTINETYPE",
"SYMBOLNAME",
"ACCESSIBILITY",
"ENUMERATION_TYPE",
"ENUMERATOR",
"CONSTVALUE",
"VOLATILETYPE",
"ENCODING",
"LINEWRAP"
);

def lineTypeToString(lineType):
    if (lineType < len(LINE_TYPE_TO_STRING)):
        return LINE_TYPE_TO_STRING[lineType];
    else:
        return 'Uknown (' + int(lineType)+')';

def parseDebugInfoDie(g0, g1, g2, g3):
    return (LINE_DIETABLE, None, None, None, None)

def parseDebugInfoName(g0, g1, g2, g3):            
    return (LINE_NAME, g0, g1, g2, g3)

def parseDebugInfoCompileUnit(g0, g1, g2, g3):     
    return (LINE_COMPILEUNIT, g0, g1, g2, g3)

def parseDebugInfoVariable(g0, g1, g2, g3):       
    return (LINE_VARIABLE, g0, g1, g2, g3)

def parseDebugInfoLocation(g0, g1, g2, g3):       
    return (LINE_LOCATION, g2, g1, g0, g3)

def parseDebugInfoType(g0, g1, g2, g3):             
    return (LINE_TYPE, g2, g1, g0, g3)

def parseDebugInfoTypedef(g0, g1, g2, g3):        
    return (LINE_TYPEDEF, g0, g1, g2, g3)

def parseDebugInfoPointerType(g0, g1, g2, g3):     
    return (LINE_POINTERTYPE, g0, g1, g2, g3)

def parseDebugInfoStructure(g0, g1, g2, g3):       
    return (LINE_STRUCTURE, g0, g1, g2, g3)

def parseDebugInfoBytesize(g0, g1, g2, g3):        
    return (LINE_BYTESIZE, g0, g1, g2, g3)

def parseDebugInfoMember(g0, g1, g2, g3):          
    return (LINE_MEMBER, g0, g1, g2, g3)

def parseDebugInfoMemberlocation(g0, g1, g2, g3): 
    return (LINE_MEMBERLOCATION, g0, g1, g2, g3)

def parseDebugInfoUnion(g0, g1, g2, g3):            
    return (LINE_UNION, g0, g1, g2, g3)

def parseDebugInfoSubprogram(g0, g1, g2, g3):          
    return (LINE_SUBPROGRAM, g0, g1, g2, g3)

def parseDebugInfoArrayType(g0, g1, g2, g3):          
    return (LINE_ARRAYTYPE, g0, g1, g2, g3)

def parseDebugInfoUpperBound(g0, g1, g2, g3):          
    return (LINE_UPPERBOUND, g0, g1, g2, g3)

def parseDebugInfoBaseType(g0, g1, g2, g3):          
    return (LINE_BASETYPE, g0, g1, g2, g3)
    
def parseDebugInfoAddressClass(g0, g1, g2, g3):          
    return (LINE_ADDRESSCLASS, g0, g1, g2, g3)

def parseDebugInfoSubrangeType(g0, g1, g2, g3):          
    return (LINE_ADDRESSCLASS, g0, g1, g2, g3)

def parseDebugInfoConstType(g0, g1, g2, g3):          
    return (LINE_CONSTTYPE, g0, g1, g2, g3)
    
def parseDebugInfoSubroutineType(g0, g1, g2, g3):          
    return (LINE_SUBROUTINETYPE, g0, g1, g2, g3)

def parseDebugInfoAccessibility(g0, g1, g2, g3):
    return (LINE_ACCESSIBILITY, g0, g1, g2, g3)
    
def parseDebugInfoSymbolName(g0, g1, g2, g3):
    return (LINE_SYMBOLNAME, g0, g1, g2, g3)

def parseDebugInfoEnumerationType(g0, g1, g2, g3):
    return (LINE_ENUMERATIONTYPE, g0, g1, g2, g3)

def parseDebugInfoEnumerator(g0, g1, g2, g3):
    return (LINE_ENUMERATOR, g0, g1, g2, g3)

def parseDebugInfoConstValue(g0, g1, g2, g3):
    return (LINE_CONSTVALUE, g0, g1, g2, g3)

def parseDebugInfoVolatileType(g0, g1, g2, g3):
    return (LINE_VOLATILETYPE, g0, g1, g2, g3)

def parseDebugInfoEncoding(g0, g1, g2, g3):
    return (LINE_ENCODING, g0, g1, g2, g3)

def parseDebugInfoLineWrap(g0, g1, g2, g3):
    return (LINE_LINEWRAP, g2, g3, g0, g1)
    
def createLinePatterns():
    patterns = [];
    patterns.append((LINE_ENUMERATOR ,       "    ([0-9a-f]{8})(.+)DW_TAG_enumerator"                                    , parseDebugInfoEnumerator))
    patterns.append((LINE_NAME ,             "    ([0-9a-f]{8})( +)DW_AT_name +(.+)"                                     , parseDebugInfoName))            
    patterns.append((LINE_VARIABLE ,         "    ([0-9a-f]{8})(.+)DW_TAG_variable"                                      , parseDebugInfoVariable))       
    patterns.append((LINE_LOCATION ,         "    ([0-9a-f]{8})( +)DW_AT_location       DW_OP_addr 0x([0-9a-f]+)"        , parseDebugInfoLocation))       
    patterns.append((LINE_TYPE ,             "    ([0-9a-f]{8})( +)DW_AT_type +.*debug_info.* +0x([0-9a-f]+)"            , parseDebugInfoType))             
    patterns.append((LINE_TYPEDEF ,          "    ([0-9a-f]{8})(.+)DW_TAG_typedef"                                       , parseDebugInfoTypedef))        
    patterns.append((LINE_POINTERTYPE ,      "    ([0-9a-f]{8})(.+)DW_TAG_pointer_type"                                  , parseDebugInfoPointerType))     
    patterns.append((LINE_STRUCTURE ,        "    ([0-9a-f]{8})(.+)DW_TAG_structure_type"                                , parseDebugInfoStructure))       
    patterns.append((LINE_BYTESIZE ,         "    ([0-9a-f]{8})( +)DW_AT_byte_size ([0-9]+)"                             , parseDebugInfoBytesize))        
    patterns.append((LINE_MEMBER ,           "    ([0-9a-f]{8})(.+)DW_TAG_member"                                        , parseDebugInfoMember))          
    patterns.append((LINE_MEMBERLOCATION ,   "    ([0-9a-f]{8})( +)DW_AT_data_member_location DW_OP_plus_uconst ([0-9]+)", parseDebugInfoMemberlocation)) 
    patterns.append((LINE_UNION ,            "    ([0-9a-f]{8})(.+)DW_TAG_union_type"                                    , parseDebugInfoUnion))            
    patterns.append((LINE_SUBPROGRAM ,       "    ([0-9a-f]{8})(.+)DW_TAG_subprogram(.+)"                                , parseDebugInfoSubprogram))          
    patterns.append((LINE_ARRAYTYPE ,        "    ([0-9a-f]{8})(.+)DW_TAG_array_type"                                    , parseDebugInfoArrayType))          
    patterns.append((LINE_UPPERBOUND ,       "    ([0-9a-f]{8})(.+)DW_AT_upper_bound +([0-9]+)"                          , parseDebugInfoUpperBound))          
    patterns.append((LINE_BASETYPE ,         "    ([0-9a-f]{8})(.+)DW_TAG_base_type"                                     , parseDebugInfoBaseType))          
    patterns.append((LINE_ADDRESSCLASS ,     "    ([0-9a-f]{8})(.+)DW_AT_address_class DW_ADDR_TI_PTR32"                 , parseDebugInfoAddressClass))          
    patterns.append((LINE_SUBRANGETYPE ,     "    ([0-9a-f]{8})(.+)DW_AT_subrange_type"                                  , parseDebugInfoSubrangeType))          
    patterns.append((LINE_CONSTTYPE ,        "    ([0-9a-f]{8})(.+)DW_TAG_const_type"                                    , parseDebugInfoConstType))
    patterns.append((LINE_SUBROUTINETYPE ,   "    ([0-9a-f]{8})(.+)DW_TAG_subroutine_type"                               , parseDebugInfoSubroutineType))
    patterns.append((LINE_SYMBOLNAME ,       "    ([0-9a-f]{8})(.+)DW_AT_accessibility\s+.+"                             , parseDebugInfoAccessibility))
    patterns.append((LINE_ACCESSIBILITY ,    "    ([0-9a-f]{8})(.+)DW_AT_TI_symbol_name +(\S+)"                          , parseDebugInfoSymbolName))
    patterns.append((LINE_ENUMERATIONTYPE ,  "    ([0-9a-f]{8})(.+)DW_TAG_enumeration_type"                              , parseDebugInfoEnumerationType))
    patterns.append((LINE_CONSTVALUE ,       "    ([0-9a-f]{8})(.+)DW_AT_const_value +([0-9]+)"                          , parseDebugInfoConstValue))
    patterns.append((LINE_VOLATILETYPE ,     "    ([0-9a-f]{8})(.+)DW_TAG_volatile_type"                                 , parseDebugInfoVolatileType))
    patterns.append((LINE_ENCODING ,         "    ([0-9a-f]{8})(.+)DW_AT_encoding +(.+)"                                 , parseDebugInfoEncoding))
    patterns.append((LINE_LINEWRAP ,         "                                            (\S+)"                         , parseDebugInfoLineWrap))
    patterns.append((LINE_COMPILEUNIT ,      "    ([0-9a-f]{8})(.+)DW_TAG_compile_unit"                                  , parseDebugInfoCompileUnit))     
    patterns.append((LINE_DIETABLE ,         "    DIE Table at Offset [0-9a-f]+"                                         , parseDebugInfoDie))
    return patterns;

PATTERNS = createLinePatterns();     

def parseDebugInfoLine(fileName, lineNum, line):
    matchFound = False
    global PATTERNS;
    (lineType, address, indent, g2, g3) = (None, None, None, None, None);
    
    patternIdx = 0
    
    # try matches 
    for (patternType, pattern, callback) in PATTERNS:
        match = re.match(pattern, line);
        if (match):
            matchFound = True  
            groups = match.lastindex;
            (g0, g1, g2, g3) = (None, None, None, None);
            if (groups > 0):
                g0 = match.group(1)
                g0 = g0.strip()
            if (groups > 1):
                g1 = match.group(2)
                g1 = g1.strip()
            if (groups > 2):
                g2 = match.group(3)
                g2 = g2.strip()
            if (groups > 3):
                g3 = match.group(4)
                g3 = g3.strip()

            (lineType, address, indent, g2, g3) = callback(g0, g1, g2, g3)
            break;
        patternIdx = patternIdx + 1
        
    if (not matchFound):
        #printError(fileName, lineNum, False, "No match");
        pass;
    else:
        #descr = getLineDescritpion(lineType, address, indent, g2, g3)
        #print descr;
        pass;

    return (matchFound, lineType, address, indent, g2, g3)

def parseGetIndentation(group):
    l = len(group);
    return l;        

def fillBlanks(s):
    return re.sub("[0-9]", " ", s)

def getLineDescritpion(lineType, address, indent, g2, g3):
    if (indent != None):
        indent = fillBlanks(indent);
        
    lineStr = lineTypeToString(lineType)
    if (lineType == LINE_DIETABLE):
        return lineStr + " ";
    if (lineType == LINE_NAME):
        return indent+lineStr+" "+address+" "+g2
    if (lineType == LINE_LINEWRAP):
        return lineStr+" "+g2
    if (lineType == LINE_COMPILEUNIT):
        return fillBlanks(address)+lineStr
    else:
        return indent+lineStr+" "+address;

STATE_IDLE = 0
STATE_DIE = 1
STATE_VARIABLE = 2
STATE_TYPEDEF = 3
STATE_UNION = 4
STATE_SKIP = 5
STATE_STRUCTURE = 6
STATE_COMPILEUNIT = 7
STATE_ARRAYTYPE = 8
STATE_BASETYPE = 9
STATE_POINTERTYPE = 10
STATE_CONSTTYPE = 11
STATE_SUBROUTINETYPE = 12
STATE_ENUMTYPE = 13
STATE_VOLATILETYPE = 14
STATE_STRUCTUREMEMBER = 15
STATE_ENUMERATOR = 16

STATE_TO_STRING = (
	"IDLE",
	"DIE",
	"VARIABLE",
	"TYPEDEF",
	"UNION",
	"SKIP",
	"STRUCTURE",
	"COMPILEUNIT",
	"ARRAYTYPE",
	"BASETYPE",
	"POINTERTYPE",
	"CONSTTYPE",
	"SUBROUTINETYPE",
	"ENUMTYPE",
    "VOLATILETYPE",
    "STRUCTUREMEMBER",
    "STATE_ENUMERATOR"
);

class fsmState:
    state = STATE_IDLE 
    indentation = 0
    nodes = Nodes();
    curNode = None;
    curStructField = None;
    curEnumerator = None; 

def stateToString(state):
    if (state < len(STATE_TO_STRING)):
        return STATE_TO_STRING[state];
    else:
        return "StateUknown";

def parseDebugInfoFsm_IDLE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_DIETABLE):
        fsmState.state = STATE_DIE;
    else:
        printError(fileName, lineNum, False, "Expected 'DIE Table at Offset...'");

def parseDebugInfoFsm_SKIP(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_NAME):
        pass;
    elif (lineType == LINE_TYPE):
        pass;
    elif (lineType == LINE_SYMBOLNAME):
        pass;
    elif (lineType == LINE_LINEWRAP):
        pass;
    else:
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));


def parseDebugInfoFsm_VARIABLE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_NAME):
        fsmState.ignoreLineWrap = False;
        fsmState.curNode.name = g2;
        pass;
    elif (lineType == LINE_TYPE):
        fsmState.curNode.typeAddress = int(address, 16);
        pass;
    elif (lineType == LINE_LOCATION):
        fsmState.curNode.location = int(address, 16);
        pass;
    elif (lineType == LINE_SYMBOLNAME):
        fsmState.state = STATE_COMPILEUNIT;
        #fsmState.ignoreLineWrap = True;
        pass;
    elif (lineType == LINE_LINEWRAP): 
        #if (not fsmState.ignoreLineWrap):
        if verboseOutput: print "LINE_LINEWRAP: "+fsmState.curNode.name+", "+g2;  
        fsmState.curNode.name = fsmState.curNode.name + g2;
        pass;
    else:
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));
        

def parseDebugInfoFsm_TYPEDEF(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_NAME):
        fsmState.curNode.name = g2; 
        pass;
    elif (lineType == LINE_TYPE):
        fsmState.curNode.typeAddress = int(address, 16); 
        fsmState.state = STATE_COMPILEUNIT;
    else:
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));
    
def parseDebugInfoFsm_STRUCTURE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_NAME):
        fsmState.curNode.name = g2; 
        pass;
    elif (lineType == LINE_BYTESIZE):
        fsmState.curNode.size = int(g2, 10); 
        pass;
    elif (lineType == LINE_MEMBER):
        fsmState.state = STATE_STRUCTUREMEMBER;
        addressInt = int(address, 16)
        structField = StructureFieldNode(lineNum, addressInt)
        fsmState.curStructField = structField;
        fsmState.curNode.fields.append(structField);
        pass;
    elif (lineType == LINE_MEMBERLOCATION):
        pass;
    elif (lineType == LINE_TYPE):
        pass;
    elif (lineType == LINE_SYMBOLNAME):
        pass;
    elif (lineType == LINE_ACCESSIBILITY):
        pass;
    else:
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));

def parseDebugInfoFsm_STRUCTUREMEMBER(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_NAME):
        fsmState.curStructField.name = g2; 
        pass;
    elif (lineType == LINE_ACCESSIBILITY):
        pass;
    elif (lineType == LINE_MEMBERLOCATION):
        fsmState.curStructField.location = int(g2, 10); 
        pass;
    elif (lineType == LINE_TYPE):
        fsmState.curStructField.typeAddress = int(address, 16); 
        pass;
    elif (lineType == LINE_SYMBOLNAME):
        fsmState.state = STATE_STRUCTURE;
        pass;
    else:
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));

def parseDebugInfoFsm_UNION(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_NAME):
        pass;
    elif (lineType == LINE_BYTESIZE):
        fsmState.curNode.size = int(g2, 10);
        pass;
    elif (lineType == LINE_MEMBER):
        pass;
    elif (lineType == LINE_ACCESSIBILITY):
        pass;
    elif (lineType == LINE_MEMBERLOCATION):
        pass;
    elif (lineType == LINE_TYPE):
        pass;
    elif (lineType == LINE_SYMBOLNAME):
        pass;
    else:
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));


def parseDebugInfoFsm_ARRAYTYPE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_BYTESIZE):
        fsmState.curNode.size = int(g2, 10);
        pass;
    elif (lineType == LINE_TYPE):
        if verboseOutput: print "Array: fsmState.curNode.typeAddress = "+address;  
        fsmState.curNode.typeAddress = int(address, 16);
        pass;
    elif (lineType == LINE_SUBRANGETYPE):
        pass;
    elif (lineType == LINE_UPPERBOUND):
        dim = int(g2, 10);
        fsmState.curNode.rangeBounds.append(dim);
        # print fsmState.curNode, fsmState.curNode.rangeBounds, dim
        pass;
    else: 
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));

def parseDebugInfoFsm_POINTERTYPE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_ADDRESSCLASS):
        pass;
    elif (lineType == LINE_TYPE):
        fsmState.curNode.typeAddress = int(address, 16);
        fsmState.state = STATE_COMPILEUNIT;
    else: 
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));

def parseDebugInfoFsm_CONSTTYPE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_TYPE):
        fsmState.curNode.typeAddress = int(address, 16);
        fsmState.state = STATE_COMPILEUNIT;
    else: 
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));
        
def parseDebugInfoFsm_VOLATILETYPE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_TYPE):
        fsmState.curNode.typeAddress = int(address, 16);
        fsmState.state = STATE_COMPILEUNIT;
    else: 
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));

def parseDebugInfoFsm_ENUMERATIONTYPE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_BYTESIZE):
        fsmState.curNode.size = int(g2);
        pass;
    elif (lineType == LINE_ENUMERATOR):
        fsmState.curEnumerator = None;
        pass;
    elif (lineType == LINE_NAME):
        fsmState.curEnumerator = g2;
        pass;
    elif (lineType == LINE_CONSTVALUE):
        val = int(g2, 10);
        fsmState.curNode.members.append((fsmState.curEnumerator, val));
        pass;
    elif (lineType == LINE_LINEWRAP):
        fsmState.curEnumerator = fsmState.curEnumerator+g2;
        pass;
    else: 
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));
        

def parseDebugInfoFsm_SUBROUTINETYPE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_TYPE):
        pass;
    elif (lineType == LINE_SYMBOLNAME):
        pass;
    else: 
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));

def parseDebugInfoFsm_BASETYPE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_NAME):
        fsmState.curNode.name = g2;
        pass;
    elif (lineType == LINE_BYTESIZE):
        fsmState.curNode.size = int(g2);
        pass;
    elif (lineType == LINE_ENCODING):
        if ((g2 == 'DW_ATE_boolean') or ("unsigned" in g2)):
            fsmState.curNode.isSigned = False;
        pass;
    else: 
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));


def parseDebugInfoFsm_DIE(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_COMPILEUNIT):
        fsmState.state = STATE_COMPILEUNIT;

    elif (lineType == LINE_NAME):
        fsmState.state = STATE_COMPILEUNIT;
        
    else:
        printError(fileName, lineNum, False, "Expected variable or typedef instead of "+lineTypeToString(lineType)+
                   " in state " + stateToString(fsmState.state));

def parseDebugInfoFsm_COMPILEUNIT(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    
    if (lineType == LINE_NAME):
        pass;
    elif (lineType == LINE_LINEWRAP):
        pass;
    else:
        fsmSwitchByLineDefault(fileName, lineNum, (lineType,address,indent,g2,g3));
    

def fsmSwitchByLineDefault(fileName, lineNum, (lineType,addressStr,indent,g2,g3)):
    global fsmState;
    
    address = None;
    if (addressStr != None):
        address = int(addressStr, 16);


    if (lineType == LINE_DIETABLE):
        fsmState.state = STATE_DIE;
    
    elif (lineType == LINE_VARIABLE):
        # print "add variable", lineNum, addressStr
        node = VariableNode(lineNum, address);
        fsmState.nodes.variables.append(node);   # add to the list of variables 
        fsmState.curNode = node;                 # set current Node
        fsmState.state = STATE_VARIABLE;
        
    elif (lineType == LINE_TYPEDEF):
        node = TypeRefNode(lineNum, address);
        fsmState.nodes.typeRefs[address] = node; # add to the dictionary
        fsmState.curNode = node;                 # set current Node
        fsmState.state = STATE_TYPEDEF;
        
    elif (lineType == LINE_STRUCTURE):
        node = StructureNode(lineNum, address);
        fsmState.nodes.types[address] = node; # add to the dictionary 
        fsmState.curNode = node;              # set current Node
        fsmState.state = STATE_STRUCTURE;

    elif (lineType == LINE_UNION):
        node = UnionNode(lineNum, address);
        fsmState.nodes.types[address] = node; # add to the dictionary 
        fsmState.curNode = node;              # set current Node
        fsmState.state = STATE_UNION;
        
    elif (lineType == LINE_ARRAYTYPE):
        node = ArrayNode(lineNum, address);
        fsmState.nodes.types[address] = node; # add to the dictionary 
        fsmState.curNode = node;              # set current Node
        fsmState.state = STATE_ARRAYTYPE;

    elif (lineType == LINE_BASETYPE):
        node = BaseTypeNode(lineNum, address);
        fsmState.nodes.types[address] = node; # add to the dictionary 
        fsmState.curNode = node;              # set current Node
        fsmState.state = STATE_BASETYPE;

    elif (lineType == LINE_SUBPROGRAM):
        fsmState.state = STATE_SKIP;
        
    elif (lineType == LINE_POINTERTYPE):
        node = PointerNode(lineNum, address);
        fsmState.nodes.types[address] = node; # add to the dictionary 
        fsmState.curNode = node;              # set current Node
        fsmState.state = STATE_POINTERTYPE;

    elif (lineType == LINE_CONSTTYPE):
        node = VolatileNode(lineNum, address);# Ugly trick - I consider const and volatile to be the same
        fsmState.nodes.types[address] = node; # add to the dictionary
        fsmState.curNode = node;              # set current Node
        fsmState.state = STATE_CONSTTYPE;
        
    elif (lineType == LINE_SUBROUTINETYPE):
        node = BaseTypeNode(lineNum, address);
        node.size = 4;
        fsmState.nodes.types[address] = node; # add to the dictionary 
        fsmState.curNode = node;              # set current Node
        fsmState.state = STATE_SUBROUTINETYPE;
        
    elif (lineType == LINE_ENUMERATIONTYPE):
        node = EnumerationTypeNode(lineNum, address);
        fsmState.nodes.types[address] = node; # add to the dictionary 
        fsmState.curNode = node;              # set current Node
        fsmState.state = STATE_ENUMTYPE;
        
    elif (lineType == LINE_VOLATILETYPE):
        node = VolatileNode(lineNum, address);
        fsmState.nodes.types[address] = node; # add to the dictionary
        fsmState.curNode = node;              # set current Node
        fsmState.state = STATE_VOLATILETYPE;
        
    else:
        printError(fileName, lineNum, False, "Expected variable or typedef instead of "+lineTypeToString(lineType)+
                   " in state " + stateToString(fsmState.state)+" "+addressStr);

FSM_TABLE = (
    parseDebugInfoFsm_IDLE,
    parseDebugInfoFsm_DIE,
    parseDebugInfoFsm_VARIABLE,
    parseDebugInfoFsm_TYPEDEF,
    parseDebugInfoFsm_UNION,
    parseDebugInfoFsm_SKIP,
    parseDebugInfoFsm_STRUCTURE,
    parseDebugInfoFsm_COMPILEUNIT,
    parseDebugInfoFsm_ARRAYTYPE,
    parseDebugInfoFsm_BASETYPE,
    parseDebugInfoFsm_POINTERTYPE,
    parseDebugInfoFsm_CONSTTYPE,
    parseDebugInfoFsm_SUBROUTINETYPE,
    parseDebugInfoFsm_ENUMERATIONTYPE,
    parseDebugInfoFsm_VOLATILETYPE,
    parseDebugInfoFsm_STRUCTUREMEMBER
);
    
def parseDebugInfoFsm(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3)):
    global fsmState;
    fsmStateOld = fsmState.state;
    
    if ((lineType != LINE_DIETABLE) and (lineType != LINE_LINEWRAP)):
        fsmState.indentation = parseGetIndentation(indent);
        
    if (fsmState.state < len(FSM_TABLE)):
        parseDebugInfo = FSM_TABLE[fsmState.state];
    else:
        print "Unknown state "+stateToString(fsmState.state);
        
    parseDebugInfo(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3));

    if ((fsmState.state != STATE_SKIP) and (fsmState.state != STATE_IDLE)):
        descr = getLineDescritpion(lineType, address, indent, g2, g3)
        #print descr;
        if (indent == None): indent = "";
        #print fillBlanks(indent)+"State:", stateToString(fsmStateOld), stateToString(fsmState.state), "line", int(lineNum), "lineType=",lineTypeToString(lineType);

        
def parseDebugInfo(fileName, file, dictInclude):
    lineNum = 1
    for line in file:
        (matchFound, lineType, address,indent,g2,g3) = parseDebugInfoLine(fileName, lineNum, line)
        if (matchFound):
            parseDebugInfoFsm(fileName, lineNum, dictInclude, (lineType,address,indent,g2,g3))
        lineNum = lineNum + 1;
        
    nodes = fsmState.nodes;
    return  (nodes.typeRefs, nodes.types, nodes.variables); 

def resolveType(typeRefs, types, typeAddress):
    type = None;
    if (typeAddress in types):          
        type = types[typeAddress];                                                             
    elif (typeAddress in typeRefs):                                                            
        typeRef = typeRefs[typeAddress];                                                       
        type = typeRef.type;
    
    return type;                                                              

def compileRefType(fileName, typeRefs, types, typeAddressIn):

    typeRef = None
    typeName = None
    pass;

    typeRefType = None;
    
    typeAddress = typeAddressIn
    while (typeAddress in typeRefs):     
        typeRef = typeRefs[typeAddress];
        typeName = typeRef.name;
        if verboseOutput: print "typeRefLoop "+strHex(typeAddress)+", name="+typeName;  
        typeRefType = resolveType(typeRefs, types, typeRef.typeAddress); 
        if (typeRefType != None):
            break;
        typeAddress = typeRef.typeAddress;

    if (typeRefType != None):
        if verboseOutput: print "compile:typeRefType != None "+strHex(typeAddress)+", name="+typeName;  
        typeAddress = typeAddressIn
        while (typeAddress in typeRefs):     
            typeRef = typeRefs[typeAddress];
            typeRef.type = typeRefType;
            #typeRef.name = typeName;
            typeAddress = typeRef.typeAddress;


def compileNode(fileName, typeRefs, types, node):
    
    if verboseOutput: print "Compile type",strHex(node.address)                 
    if (node.isVolatile()):                                                                                                    
        if (node.type != None): return;                                                                                          
        typeAddress = node.typeAddress                                                                                             
        if (typeAddress == None): return;                                                                                                              
        if verboseOutput: print "volatile = ",strHex(typeAddress), strHex(node.address)                                           
        type = resolveType(typeRefs, types, typeAddress);                                                                          
        if (type == None):                                                                                                         
            printError(fileName, node.lineNum, False,                                                                              
                "volatile Type "+strHex(node.address)+": has no type "+strHex(typeAddress));                                       
        else:                                                                                                                      
            if verboseOutput: print "volatile = ",strHex(typeAddress), strHex(type.address), type.name, type.size
            node.type = type;
            if ((type.isVolatile() and type.type != None)):  # if this is volatile const (type inside of type)
                if verboseOutput: print "type.isVolatile() and type.type != None",strHex(typeAddress), strHex(type.address)
                node.type = type.type;
                                                                                                                  
                                                                                                                  
    if (node.isPointer()):                                                                                                         
        if (node.type != None): return;                                                                                          
        typeAddress = node.typeAddress                                                                                             
        if (typeAddress == None): return;                                                                                                              
        if verboseOutput: print "pointer = ",strHex(typeAddress), strHex(node.address)                                            
        type = resolveType(typeRefs, types, typeAddress);                                                                          
        if (type == None):                                                                                                         
            printError(fileName, node.lineNum, False,                                                                              
                "pointer Type "+strHex(node.address)+": has no type "+strHex(typeAddress));                                               
        node.type = type;
                                                                                                                  
    if (node.isArray()):                                                                                                           
        if (node.type != None): return;                                                                                          
        typeAddress = node.typeAddress                                                                                             
        if verboseOutput: print "array = ",strHex(typeAddress), strHex(node.address)                                              
        type = resolveType(typeRefs, types, typeAddress);                                                                          
        if (type == None):                                                                                                         
            printError(fileName, node.lineNum, False,                                                                              
                "Array Type "+strHex(node.address)+": has no type "+strHex(typeAddress));                                               
        node.type = type;
                                                                                                                  
    if (node.isStructure()):                                                                                                       
        for field in node.fields:                                                                                                  
            typeAddress = field.typeAddress;                                                                                       
            type = resolveType(typeRefs, types, typeAddress);                                                                      
            if (type == None):                                                                                                     
                printError(fileName, node.lineNum, False,                                                                          
                    "Structure type "+strHex(node.address)+": No type for field "+ field.name+" address "+strHex(typeAddress));
            else:
                compileNode(fileName, typeRefs, types, type) # recursive call
                if (type.isVolatile()): 
                    field.type = type.type;
                elif (type.isPointer()):
                    field.type = type;
                else:                                                                                                     
                    field.type = type;
    
def compileTypes(fileName, typeRefs, types):
    
    for (key, node) in typeRefs.iteritems():
        if verboseOutput: print "typeRefAddress = ",strHex(node.address)
        compileRefType(fileName, typeRefs, types, node.address);

    for (key, node) in types.iteritems():
        compileNode(fileName, typeRefs, types, node);
        
 
def compileDictionary(fileName, typeRefs, types, variables):
    
    compileTypes(fileName, typeRefs, types);
    
    for variable in variables:
        typeAddress = variable.typeAddress;
        typeName = None
        if verboseOutput: print variable.name+":type "+strHex(typeAddress);
        variableType = resolveType(typeRefs, types, typeAddress);  
        if (variableType != None):     
            typeName = variableType.name;
            if verboseOutput: print variable.name+":typeAddress=", strHex(variableType.address), strHex(variable.address);

        if (variableType != None):
            if verboseOutput: print variable.name+":variableType != None", strHex(variableType.address), strHex(variable.address);  
            variable.type = variableType;
            if ((variable.type != None) and variable.type.isVolatile()): # if this is volatile const (type inside of type)
                if verboseOutput: print variable.name+":variableType.isVolatile()", strHex(variableType.address), strHex(variable.address);
                variable.type = variable.type.type;
        else:
            printError(fileName, variable.lineNum, False, 
                "Variable "+strHex(variable.address)+": No type for address "+strHex(typeAddress));

def getIndentation(indentation):
    s = " " * 4 * indentation;
    return s;

def writeFileRaw(fileRaw, indentation, s):
    fileRaw.write(getIndentation(indentation) + s + "\n");

def writeFileShellComment(fileShell, indentation, s):
    fileShell.write(getIndentation(indentation) + "# " + s + "\n");
        
def writeFileShell(fileShell, indentation, s, newLine = True):
    if (newLine):
        fileShell.write(getIndentation(indentation) + s + "\n");
    else:
        fileShell.write(getIndentation(indentation) + s);
     
def getArrayDimensionString(arrayObject):
    rangeBounds = arrayObject.rangeBounds;
    s = ""
    for rangeBound in rangeBounds:
        s = s + "[" + str(rangeBound) + "]"
    return s; 
    
    
def generateRawArray(fileRaw, indentation, typeRefs, types, type):
    indentation = indentation + 1;
    
    dims = getArrayDimensionString(type);
    writeFileRaw(fileRaw, indentation, "Dump array: bytes={0},dimensions={1}".format(type.size, dims));
    pass;

def generateRawPointer(fileRaw, indentation, typeRefs, types, type):
    indentation = indentation + 1;
    
    writeFileRaw(fileRaw, indentation, "Read pointer");  
    pass;


def generateRawStructure(fileRaw, indentation, typeRefs, types, type):
    indentation = indentation + 1;
    
    writeFileRaw(fileRaw, indentation, "Dump structure: type={0}, bytes={1}, typeAddr={2}".format(type.name, type.size, strHex(type.address)));  
    for field in type.fields:
        if (field.type != None):
            fieldType = field.type;
            if (fieldType.isPointer()):
                generateRawPointer(fileRaw, indentation, typeRefs, types, fieldType)
            else:
                writeFileRaw(fileRaw, indentation+1, "Read field: name={0}, type={1}, size={2}, typeAddr={3}".format(field.name, type.name, type.size, strHex(type.address)));
            if verboseOutput: print "fieldType.address2", strHex(field.address), strHex(fieldType.address), field.name, strHex(type.address) 
            if (fieldType.isStructure()):
                if verboseOutput: print "fieldType.address", strHex(field.address), strHex(fieldType.address), field.name, strHex(type.address) 
                generateRawStructure(fileRaw, indentation, typeRefs, types, fieldType) # recursive call
                pass;
        else:  
            writeFileRaw(fileRaw, indentation, "Skip field: name={0}".format(field.name));
        

def generateRawBaseType(fileRaw, indentation, typeRefs, types, type):
    indentation = indentation + 1;
    
    writeFileRaw(fileRaw, indentation, "Read {0} bytes".format(type.size));  
    pass;

def generateRawVariable(fileName, fileRaw, indentation, typeRefs, types, variable, variableType):
    while (True):
        if (variableType == None):                                                                                       
            break;                                                                                                       
                                                                                                                         
        if verboseOutput: print "Handle variable", strHex(variable.address), strHex(variable.typeAddress), variableType; 
        writeFileRaw(fileRaw, indentation, "{0} {1}".format(variable.name, strHex(variable.location)))               
                                                                                                                         
        if (variableType.isArray()):                                                                                     
            generateRawArray(fileRaw, indentation, typeRefs, types, variableType);                                   
            break;                                                                                                       
                                                                                                                         
        if (variableType.isPointer()):                                                                                   
            generateRawPointer(fileRaw, indentation, typeRefs, types, variableType);                                 
            break;                                                                                                       
                                                                                                                         
        if (variableType.isStructure()):                                                                                 
            generateRawStructure(fileRaw, indentation, typeRefs, types, variableType);                               
            break;                                                                                                       
                                                                                                                         
        if (variableType.isBaseType()):                                                                                  
            generateRawBaseType(fileRaw, indentation, typeRefs, types, variableType);                                
            break;                                                                                                       
                                                                                                                         
        if (variableType.isUnion()):                                                                                     
            generateRawBaseType(fileRaw, indentation, typeRefs, types, variableType);                                
            break;                                                                                                       
                                                                                                                         
        printError(fileName, variable.lineNum, False,                                                                    
            "Variable={0}: No handling for type {1}".format(strHex(variable.address), strHex(variable.type.address)));   
        break;                                                                                                           
    
def generateRaw(fileName, dictInclude, fileRaw, typeRefs, types, variables):
    indentation = 0;
    for variable in variables:
        if ((variable.name != None) and isInDictInclude(dictInclude, variable.name)):  
            generateRawVariable(fileName, fileRaw, indentation, typeRefs, types, variable, variable.type)
    



def generateShellArray(fileShell, indentation, typeRefs, types, type, location, prefix=""):
    indentationStr = getIndentation(indentation);
    
    dims = getArrayDimensionString(type);
    locationStr = strHex(location)
    indentationStr = getIndentation(indentation);

    if ( (type.type != None) and type.type.isStructure() and (len(type.rangeBounds) == 1) ):
        dim = type.rangeBounds[0];
        elemSize = type.type.size;
        for i in range(dim):
            generateShellStructure(fileShell, indentation, typeRefs, types, type.type, location+elemSize*i);
    else:
        writeFileShell(fileShell, indentation+1, 
            "dd bs=4 count={0} skip=$((0x{1}/4)) if=$DEV_MEM | hexdump -n {2} -C".format(type.size/4, locationStr, type.size));  


def generateShellPointer(fileShell, indentation, typeRefs, types, type, location, prefix=""):
    indentationStr = getIndentation(indentation);
    locationStr = strHex(location)
    writeFileShell(fileShell, indentation, 
        "dd bs=4 count=1 skip=$((0x{0}/4))  if=$DEV_MEM  2> /dev/null  | hexdump -n 4 -e '1/4 \"%04x\\n\"'".format(locationStr));  
    pass;


def generateShellStructure(fileShell, indentation, typeRefs, types, type, location, prefix=""):
    indentationStr = getIndentation(indentation);
    writeFileShell(fileShell, indentation, "echo '{2}type={0}, bytes={1}'".format(type.name, type.size, indentationStr))                                   
    for field in type.fields:
        if (field.type != None):
            
            fieldType = field.type;
            fieldLocation = location+field.location;
            fieldName = field.name;
            
            if (fieldType.isPointer()):
                generateShellPointer(fileShell, indentation+1, typeRefs, types, fieldType, fieldLocation, fieldName)
                
            elif  (fieldType.isBaseType()):
                generateShellBaseType(fileShell, indentation+1, typeRefs, types, fieldType, fieldLocation, fieldName)
                
            elif  (fieldType.isArray()):
                writeFileShell(fileShell, indentation, "echo {0}".format(fieldName))                                   
                generateShellArray(fileShell, indentation, typeRefs, types, fieldType, fieldLocation, fieldName)
                
            elif (fieldType.isStructure()):
                writeFileShell(fileShell, indentation, "echo {0}".format(fieldName))                                   
                generateShellStructure(fileShell, indentation+1, typeRefs, types, fieldType, fieldLocation, fieldName)

        else:  
            printError("", 1, False, "Skip field: name={0}".format(fieldName));
        

def generateShellBaseType(fileShell, indentation, typeRefs, types, type, location, prefix=""):
    indentationStr = getIndentation(indentation);
    locationStr = strHex(location)
    writeFileShell(fileShell, indentation, 
        "dd bs=4 count=1 skip=$((0x{0}/4))  if=$DEV_MEM  2> /dev/null  | hexdump -n 4 -e '1/4 \"{2}{1} %04x\\n\"'".format(locationStr, prefix, indentationStr));  

def generateShellVariable(fileName, fileShell, indentation, typeRefs, types, variable, variableType):
    indentationStr = getIndentation(indentation);
    while (True):
        if (variableType == None):                                                                                       
            break;

        variableLocation = variable.location;                                                 
                                                                                                                         
        if verboseOutput: print "Handle variable", strHex(variable.address), strHex(variable.typeAddress), variableType; 
                                                                                                                         
        if (variableType.isArray()):                                                  
            writeFileShell(fileShell, indentation, "{0})".format(variable.name))                                   
            generateShellArray(fileShell, indentation+1, typeRefs, types, variableType, variableLocation);                                   
            writeFileShell(fileShell, indentation, ";;")                                   
            break;                                                                                                       
                                                                                                                         
        if (variableType.isPointer()):                                                                                   
            writeFileShell(fileShell, indentation, "{0})".format(variable.name))                                   
            generateShellPointer(fileShell, indentation+1, typeRefs, types, variableType, variableLocation);                                 
            writeFileShell(fileShell, indentation, ";;")                                   
            break;                                                                                                       
                                                                                                                         
        if (variableType.isStructure()):                                                                                 
            writeFileShell(fileShell, indentation, "{0})".format(variable.name))                                   
            writeFileShellComment(fileShell, indentation, "{0} type={1}, bytes={2}".format(variable.name, variableType.name, variableType.size))                                   
            generateShellStructure(fileShell, indentation+1, typeRefs, types, variableType, variableLocation);                               
            writeFileShell(fileShell, indentation, ";;")                                   
            break;                                                                                                       
                                                                                                                         
        if (variableType.isBaseType()):                                                                                  
            writeFileShell(fileShell, indentation, "{0})".format(variable.name))                                   
            generateShellBaseType(fileShell, indentation+1, typeRefs, types, variableType, variableLocation);                                
            writeFileShell(fileShell, indentation, ";;")                                   
            break;                                                                                                       
                                                                                                                         
        if (variableType.isUnion()):                                                                                     
            writeFileShell(fileShell, indentation, "{0})".format(variable.name))                                   
            generateShellBaseType(fileShell, indentation+1, typeRefs, types, variableType, variableLocation);                                
            writeFileShell(fileShell, indentation, ";;")                                   
            break;                                                                                                       
                                                                                                                         
        printError(fileName, variable.lineNum, False,                                                                    
            "Variable={0}: No handling for type {1}".format(strHex(variable.address), strHex(variable.type.address)));   
        break;                                                                                                           
    
def generateShell(fileName, dictInclude, fileShell, typeRefs, types, variables):
    indentation = 0;
    
    writeFileShellComment(fileShell, indentation, "Automatically generated shell script");  
    writeFileShellComment(fileShell, indentation, "See http://www.assembla.com/code/OpenTI/subversion/nodes/scripts/global_types_gen.py ");
    writeFileShellComment(fileShell, indentation, "export DEV_MEM=/sys/kernel/debug/ieee80211/phy0/wlcore/mem");
    writeFileShell(fileShell, indentation, "case $1 in");
    for variable in variables:
        if ((variable.name != None) and isInDictInclude(dictInclude, variable.name)): 
            generateShellVariable(fileName, fileShell, indentation, typeRefs, types, variable, variable.type)
    writeFileShell(fileShell, indentation, "*)".format(variable.name))                                   
    writeFileShell(fileShell, indentation+1, "echo Unknown variable $1")                                   
    writeFileShell(fileShell, indentation, "esac");

def isInDictInclude(dictInclude, s):
    for (key, (lineNum, pattern, isRegEx)) in dictInclude.iteritems():
        if (isRegEx):
            match = re.match(pattern, s);
            if (match):
                return True;
        else:
            if (s == pattern):
                return True;

    return False;
        
    
       
def mainLoop():
    global verboseOutput; 
    global cmdOptions;
    global fsmState;
    
    parser = createOptionsParser();

    # run the command line options parser
    # parse command line arguments
    (cmdOptions, args) = parser.parse_args();
    
    if (cmdOptions.verboseOutput == 'true'):
        print 'Verbose output is on';
        verboseOutput = True;
    else:
        verboseOutput = False;

    
    fileDebugInfo = False;
    fileInclude = False;
    fileShell = False;
    fileRaw = False;

    # if unrecoverable error I am going to break out of the loop
    while (True):
        argsOk = checkArgs(cmdOptions);
        if (not argsOk):
            parser.print_help();
            break;

        if (verboseOutput):        
            print 'Process file "{0}"'.format(cmdOptions.debugInfoFile);
            

        dictInclude = {};
        if (cmdOptions.includeFile):
            fileName = cmdOptions.includeFile;
            (openOk, fileInclude) = openFile(fileName, "rt");
            if (not openOk):
                print 'Failed to open file "{0}" for reading'.format(fileName);
                break;
            readIncludeList(cmdOptions.includeFile, fileInclude, dictInclude);
        else:                                             
            regEx = ".+";                                     # no include list means include all 
            dictInclude[regEx] = (0, regEx, True);

        fileName = cmdOptions.debugInfoFile;
        
        # try to open file containing debug information
        (openOk, fileDebugInfo) = openFile(fileName, "rt")
        if (not openOk):
            print 'Failed to open file "{0}" for reading'.format(fileName);
            break;

        (typeRefs, types, variables) = parseDebugInfo(fileName, fileDebugInfo, dictInclude);
        compileDictionary(fileName, typeRefs, types, variables);
        
        if (cmdOptions.generateShell != None):
            fileName = cmdOptions.generateShell;
            (openOk, fileShell) = openFile(fileName, "wt")
            if (not openOk):
                print 'Failed to open file "{0}" for writing'.format(fileName);
                break;
            generateShell(fileName, dictInclude, fileShell, typeRefs, types, variables);

        if (cmdOptions.generateRaw != None):
            fileName = cmdOptions.generateRaw
            (openOk, fileRaw) = openFile(fileName, "wt")
            if (not openOk):
                print 'Failed to open file "{0}" for writing'.format(fileName);
                break;
            generateRaw(fileName, dictInclude, fileRaw, typeRefs, types, variables);
            
        for node in fsmState.nodes.variables:
            #node.dbgPrint();
            pass;
        for (key, node) in fsmState.nodes.typeRefs.iteritems():
            #node.dbgPrint();
            pass;
        for (key, node) in fsmState.nodes.types.iteritems():
            #node.dbgPrint();
            pass;

#        try:
#            _ = parseDebugInfo(fileName, fileDebugInfo, dictInclude);
#        except Exception:
#            print Exception;
#            print 'Failed to parse file {0}'.format(fileName);
#            break;
#        else:
#            pass;
        
        # break out of loop - everything is alright
        break;

    # do final cleanup - close opened files
    if (fileDebugInfo):         fileDebugInfo.close();
    if (fileInclude):           fileInclude.close();
    if (fileShell):             fileShell.close();
    if (fileRaw):               fileRaw.close();
    
# endof mainLoop()    

# first code to be executed - calls 'main' processing loop
if __name__ == "__main__":
    mainLoop();
    print 'Done';